https://thebookofshaders.com/00/?lan=jp
網点
2枚目はシアン、マゼンタ、イエロー、ブラックの4色の網点の組み合わせでほんの短い時間で生み出されました。

活版
フラグメントシェーダーは印刷にとってのグーテンベルグの活版技術に匹敵すると考えることもできます。

驚くようなクオリティ
そのためこの技術はスマートフォンで映像にフィルターをかけることから、驚くようなクオリティの3Dゲームまで、様々な用途に使われています。

線形代数 三角関数
この本はプログラムの経験と基本的な線形代数や三角関数の知識があり、ワンランク上のグラフィックを目指すクリエイティブコーダー、ゲームデベロッパーなどの開発者に向けて書かれています。

取り上げる
この本で取り上げること
この本では主にGLSLのフラグメントシェーダーについて説明します。

質感
シェーダーとは何かの定義から始まり、プログラムを用いて形や模様、質感や動きを作る方法を学びます。

畳み込み
シェーダー言語の基礎とともに、畳み込み、ぼかし、カラーフィルター、ルックアップテーブルなどの画像処理技術。。。

波紋
コンウェイのライフゲーム、グレイ=スコットの反応拡散系、水の波紋、水彩、ボロノイ図のようなシミュレーションなど

含むより
この本はOpenGLやWebGLの本ではありません。OpenGL、WebGLはGLSLやフラグメントシェーダーを含むより広範なトピックです。

https://thebookofshaders.com/01/?lan=jp
長方形
コンピュータで絵を描いた経験があれば、円や長方形、線、三角などを組み合わせて自分の描きたいものを作る方法を知っているでしょう。

?版？type press? weird font ❌

桁外れに
コンパイルされたシェーダーは桁外れに速く処理を行うことができます。

並列
シェーダーはなぜ速いのか
その秘密は並列処理にあります。

訳注
(訳注：CPU=パイプ=スレッドのように読めますが、実際にはスレッドはCPUを通る処理の単位として分けて考えた方が正確だと思います。Wikipedia: スレッド (コンピュータ) 参照。この後の方にも同様の部分が出てきますがおよその意味は通じると思うのでそのまま訳します。)

解像度
 解像度が大きくなっても理屈は同じです。並列に処理できる数が多いほど、より大きなデータの流れを扱うことができます。

標準化
GLSLはopenGL Shading Languageの略で、標準化されたシェーダー言語の1つです。

策定
ここからはクロノスグループによって策定されたOpenGLの仕様に基づいて話を進めます。

言語仕様上
OpenGLの歴史を知っておくと奇妙な（訳注：プログラミング、言語仕様上の）慣習を理解する助けになるかもしれません。openglbook.com/chapter-0-preface-what-is-opengl.htmlに軽く目を通しておくと良いでしょう。

「大いなる力には、大いなる責任が伴う」
スパイダーマンの父親がわりだったベンおじさんは「大いなる力には、大いなる責任が伴う」と言い残しましたが、これは並列処理にも当てはまります。

独立
全てのパイプ、またはスレッドを並列で走らせるためには、それぞれが他のスレッドから独立していなければなりません。

一貫した
スレッド間のやりとりを可能にしてしまうと、データ全体としての一貫した処理を損なうことになりかねません。

https://thebookofshaders.com/02/?lan=jp
高らか
新しいプログラミング言語を学ぶときはたいてい最初に「Hello World」を表示します。一行のシンプルなプログラムで新しい世界に高らかにご挨拶というわけです。

大仕事
しかしGPUの世界で文字を書くのは第一歩にしてはかなりの大仕事です。

置き換える
GPUは変更した内容を反映してコードをコンパイルし、シェーダーを即座に置き換えます。

6行目❌8行目

予約語
最終的なピクセルの色は、予約語として確保されたグローバル変数、gl_FragColorに割り当てられます。

組み込み
このCによく似た言語には（gl_FragColorのような）組み込みの「変数」や「関数」、「型」があります。

緑 Green, weird font ❌

透過
vec4型をよく見ると、4つの引数はそれぞれ赤（Red）、緑（Green）、青（Blue）、透過度（Alpha）の各チャンネルに対応していることが分かるでしょう。

正規化
またこれらの値が正規化されている、つまり 0.0 から 1.0 の値をとることも読み取れます。

写像
後ほど、値が正規化されていると変数間の写像に便利であることを学びます。

挿入
上のサンプルでは、GL_ES が定義されているときにだけ2行目のコードを挿入します。

浮動小数点 + 精度
浮動小数点型はシェーダーに不可欠で、その精度はとても重要な意味を持ちます。

仕様 + 型変換
最後に、そしておそらく一番大切なことですが、GLSLの仕様では変数の自動的な型変換は保証されていません。

割り当てる
上のサンプルでは vec4 型は浮動小数点精度を持っているので、float 型の値が割り当てられることになっています。

非推奨

6行目 ❌ second non updated LoC

https://thebookofshaders.com/03/?lan=jp
割り当て （て形ではなく！）
ここまで、GPUが沢山のスレッドを並列に処理する様子を見てきました。それぞれのスレッドは画像の各部分への色の割り当てを受け持っています。

やりとり
シェーダーではスレッド間の情報のやりとりを行うことはできませんが、CPUからそれぞれのスレッドに入力を送ることはできます。

読み取り専用
グラフィックカードは全てのスレッドにまったく同じ入力を、読み取り専用で送るように設計されています。

billboard？英語の部分

慣例
ここでは変数の種類を示すためにuniform変数の名前は u_ で始めるという慣例に従っていますが、他の場所では異なる名前が使われているのも見かけることでしょう。

挙げる・14. to give (an example, etc.); to cite
訳注：uniform変数は開発者が自由に名前を決めることができ、上で挙げられている用途以外にも自由に使うことができます。

https://thebookofshaders.com/04/?lan=jp
に当たり
この本を書くに当たり自分自身の練習も兼ねて、シェーダーを書いて表示したり、シェアしたり、まとめたりする為のツールを作成しました。

要素
ご覧の通り、必要なのは class="glslCanvas" を指定した canvas 要素に data-fragment-urlでシェーダーのURLを指定することだけです。

https://thebookofshaders.com/05/?lan=jp
シェイピング関数

変形
しかし、次元をまたいでのデータの変形にさらに深く踏み込む前に、ずっとシンプルなことから修行を始めなければなりません。

枠組
私たちにとってミヤギさんの壁に当たるものは、下記に示すコードの枠組みです。

20行目と26行目 ❌ non updated LoC

線形補間
このサンプルのx座標とy座標（または明るさ）の1対1の対応は線形補間と呼ばれています。

形作る
ここから私たちは数学的な関数を使って線を形作っていくことになります

iniear Interpolatio ? n ❌ weird text

訳語
この章の原文ではInterpolateという単語が複数回登場しますが、厳密な使い方ではない箇所もあるため以下では「補完」という訳語はあてませんでした

~しておく
面白いでしょう？ 19行目の指数（5.0）を他の数に変えてみましょう。例えば値を 20.0, 2.0, 1.0, 0.0, 0.2, 0.02 に変えてみます。この値と指数の関係を理解しておくととても役立ちます。

鍼
この例のように数学的な関数を様々な場面で用いると、コードを表現豊かに操ることができます。鍼で気の流れを操るようにデータの流れを操るのです。

閾値
step() 関数は2つのパラメーターを受け取ります。1つめは境界または閾値で、2つめはこの関数によってチェックされる値です。

数値
もう1つ、smoothstep()と呼ばれる関数があります。2つの数値からなる範囲ともう1つの値を受け取ると、この関数はその範囲の間で0.0から1.0まで滑らかに変化する数値を返します。

x軸
この関数をx軸に沿って見ていくと、それぞれの点で特定のyの値に対して急激に高い値を返しています。

親しむ
数学を使ってアニメーションや形を作ったり、値を組み合わせたりしたいのであれば、サインとコサインに親しんでおくに越したことはありません。

並み
この２つの基本的な三角関数を一緒に使うと円を作ることができます。これは冒険野郎マクガイバーのスイスアーミーナイフ並みに便利です。

かいつまんで + 円周
かいつまんで言うと、これらの関数は（ラジアンを単位とする）角度を受け取り、半径を1とする円周上の点のx座標 (cosine) とy座標(sine) を返します。

見事
三角関数と円の関係について全てを言葉で説明するのは難しいのですが、上のアニメーションはそれを見事に示してくれています。

周期
時間を使った以前のサンプルでも見たとおり、このサインの周期的な動きはアニメーションに使えます。

周波数
sinを計算する前に時間の値（u_time）をxに掛けてみましょう。周波数が次第に増えて波の幅が狭くなっていく様子を見てください。

累積
u_timeはページを読み込んでからの累積時間なので、ここまで読み進める間にかなり大きな値になっている可能性があります

振幅
sin(x) に 2.0 を掛けてみましょう。振幅が倍になります。

軌跡
sin(x) の絶対値（abs()）を計算してください。弾むボールの軌跡のように見えるでしょう。

少数部分
sin(x) の値から少数部分だけを取り出してみましょう（fract()）。

整数
sin(x) の値を超える最小の整数（ceil()）と、それより小さい最大の整数（floor()）を足して、1 と -1 だけからなるデジタル波を作ってみましょう。

移植
自分のスニペット集を作るために、これらの関数をGLSLに移植してみると良いでしょう。